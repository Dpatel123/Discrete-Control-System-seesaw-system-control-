% -------------------------------------------------------------------
%  Generated by MATLAB on 7-Jun-2020 15:54:12
%  MATLAB version: 9.6.0.1072779 (R2019a)
%  Dharmesh Patel
% -------------------------------------------------------------------
% Task-01

Jb = 0.5 % Jb=0.5 Kg.m^2
mf=0.1 %mf = 0.1 KG
h=0.1 % h=10cm
g=9.81 % 9.81 m.s^2

Jconst=Jb+mf*h^2 % J_B + m_F. h^2

% Task-02 
A = [0,mf*g*h/Jconst,0,-(mf*g)/Jconst;1,0,0,0;0,-g,0,0;0,0,1,0]; 
B = [1/Jconst;0;0;0]; 
c = [0,0,0,1]; 
C = eye(4) 
D = [0;0;0;0];

% Task 4

S = [B A*B A^2*B A^3*B]   % Controllability matrix
R = rank(S);                            % Rank of Controllability matrix
Si = inv(S)                              % Inverse of Controllability matrix
q = Si(4, 1:4)      	             % Last Row Of Inverse Controllability matrix
alpha = poly([-1 -1 -1 -1])  % desired poles
Ct = [0 0 0 1]                          % output position
K = q * (alpha(5)*eye(4) + alpha(4)*A + alpha(3)*A^2 + alpha(2)*A^3 + A^4)
% Ackermann’s formula
P = 1/(Ct*inv((B*K)-A)*B) % pre-amplifier gain

% task-05 
%State feedback with PI 
Api=[A [0;0;0;0]; -Ct 0] 
Bpi=[B;0] 
Ci=[0,0,0,1,0] 
Cpi=eye(5) 
Dpi=[0;0;0;0;0] 
SI=[Bpi Api*Bpi Api^2*Bpi Api^3*Bpi Api^4*Bpi] %Controllability Matrix 
RI=rank(SI) %Rank Of Inverse Controllability Matrix 
SI_i=inv(SI) %Inverse Controllability Matrix 
qI=SI_i(5, 1:5) % Las Row of Inverse Controllability matrix 
alpha = poly([ -1 -1 -1 -1 -1]) % Desired poles 
Kpi = qI*(alpha(6)*eye(5) + alpha(5)*Api + alpha(4)*Api^2 + alpha(3)*Api^3 + alpha(2)*Api^4 + alpha(1)*Api^5) % ackermann's formula 
Ki = Kpi(1:4)-(P*Ct); %Value of state feedback 

Pi = -Kpi(5) % Gain of Integral

% Task-06
% Discrete PI system

Ts=125e-6 % sampling time
sys1=c2d(ss(A,B,C,D),Ts) % continuous system
[AD,BD,CD,DD]=ssdata(sys1) % accessing data of discrete system
sysd=c2d(ss(Api,Bpi,Ci,0),Ts) % discrete system
[Adi,Bdi,cdi,Ddi]=ssdata(sysd) % accessing data of discrete system
Sd=[Bdi Adi*Bdi Adi^2*Bdi Adi^3*Bdi Adi^4*Bdi] % controllability matrix 
Rd=rank(Sd) % rank of the controllability matrix
Sd_i=inv(Sd) % inverse of controllability matrix
qdi=Sd_i(5, 1:5) % last row of the inverse controllability matrix
tf_pi=tf([1],poly([-1 -1 -1 -1 -1 ])) % transfer function for desired poles
tfd=c2d(tf_pi,Ts) % converting transfer function to discrete
[zeros_d,poles_d]=tfdata(tfd,'v') 
Ktd=qdi*(poles_d(6)*eye(5)+poles_d(5)*Adi+poles_d(4)*Adi^2+ poles_d(3)*Adi^3+poles_d(2)*Adi^4+ poles_d(1)*Adi^5) %Ackermann’s formula
pi_d=-Ktd(5) % discrete integrator gain
Kpd=Ktd(1:4)-(P*Ct) %Value of state feedback 

% Task-07
% Observer based on the linear seesaw system.

x1=[0 0 0 1]; % initial condition 
Ct1=C(4,1:4)
Mo=[Ct1; Ct1*A; Ct1*(A^2); Ct1*(A^3)] % Observability matrix
Mo_inv=inv(Mo) % inverse of Observability matrix
Qt_o=Mo_inv(1:4,4) % last column of inverse of Observability matrix
alpha_o=poly([-3 -3 -3 -3]) % polynomial
Kalpha_o=(alpha_o(5)*eye(4) + alpha_o(4)*A + alpha_o(3)*(A^2)+ alpha_o(2)*(A^3) + (A^4)) %Ackermann’s formula
 
h1=((Kalpha_o)*(Qt_o)) % error feedback vector

% Make the parallel model time discrete (zero-order-hold)
 
c_TF_o=tf([1],poly([-3 -3 -3 -3])) % transfer function for desired poles
d_TF_o=c2d(c_TF_o,Ts) % converting transfer function to discrete  
[num_o,den_o]=tfdata(d_TF_o,'v')
 
Kt_o=acker(AD.',CD(4,1:4).',(roots(den_o)).')
 
Kt_o_new=Kt_o.'

% Discrete State Observer

x2=[0;0;0;1] % initial condition
sys=ss(A,B,C,D)
sysd=c2d(sys,Ts) % Bi-linear transformation
[Ad_obs,Bd_obs,Cd_obs,Dd_obs]=ssdata(sysd)
cTd_obs=Cd_obs(4,1:4)
desys=tf([1],poly([-3 -3 -3 -3])) % desired polynominals of step response transfer function 
desysd=c2d(desys,Ts) % Converting the tf into Discrete
[num_poly,den_poly]=tfdata(desysd,'v')
poly_space = roots(den_poly)
k_obs_d = acker(Ad_obs.',cTd_obs.',poly_space.') % Ackermann’s formula
h_ons_d = k_obs_d.' 



